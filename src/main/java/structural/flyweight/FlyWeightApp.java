package structural.flyweight;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

/**
 * Created by Arsen on 5/8/2017
 */
public class FlyWeightApp {
    public static void main(String[] args) {
        List<Integer> seeds = Arrays.asList(1, 2, 3, 1, 2, 3, 1, 3, 10, 3, 3, 1, 10, 10, 11, 1, 10);// values repeat

        List<HeavyObject> objects = seeds.stream().map(HeavyObjectsCache::get).collect(Collectors.toList());
        assert objects.size() < seeds.size(); // because many of them were gotten from "cache"
    }
}

/**
 * Flyweight object:
 * Contains a very big list! This list is auto generated by given int value. So objects with same value of that int have
 * the same lists. This means we can share them! We can also use this int only to calculate hashcode and define equals.
 */
class HeavyObject {
    private final List<Long> bigList;

    HeavyObject(int seed) {
        this.bigList = LongStream.range(0, (long) Math.pow(2, seed)).boxed().collect(Collectors.toList());
    }

    public List<Long> getBigList() {
        return bigList;
    }

    public int getSeed() {
        return bigList.size();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        HeavyObject that = (HeavyObject) o;

        return bigList != null ? bigList.size() == that.bigList.size() : that.bigList == null;
    }

    @Override
    public int hashCode() {
        return bigList != null ? bigList.size() * 37 : 0;
    }
}

class HeavyObjectsCache {
    private static final ConcurrentHashMap<Integer, HeavyObject> map = new ConcurrentHashMap<>();

    private HeavyObjectsCache() {
    }

    static HeavyObject get(int seed) {
        return map.computeIfAbsent(seed, HeavyObject::new);
    }

}



